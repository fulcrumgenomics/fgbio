/*
 * The MIT License
 *
 * Copyright (c) 2025 Fulcrum Genomics LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package com.fulcrumgenomics.umi

import com.fulcrumgenomics.FgBioDef._
import com.fulcrumgenomics.bam.api.{SamOrder, SamSource, SamWriter}
import com.fulcrumgenomics.cmdline.{ClpGroups, FgBioTool}
import com.fulcrumgenomics.commons.io.Io
import com.fulcrumgenomics.commons.util.LazyLogging
import com.fulcrumgenomics.sopt._
import com.fulcrumgenomics.umi.VanillaUmiConsensusCallerOptions._
import com.fulcrumgenomics.util.NumericTypes.PhredScore
import com.fulcrumgenomics.util.ProgressLogger

@clp(description =
  """
    |Calls consensus sequences from reads generated from the the CODEC protocol[1]. Prior to running this tool, reads
    |must have been grouped with `GroupReadsByUmi` using the `adjacency` or `identity` strategy (NOT `paired`).
    |
    |Reads from the same original duplex are collected, and the R1s and R2s assembled into single strand consensus
    |reads as described by CallMolecularConsensusReads.  Subsequently a single consensus read is generated including
    |both any single-strand regions as well as the double-stranded region of the template.
    |
    |The consensus reads produced are unaligned, due to the difficulty and error-prone nature of inferring the consensus
    |alignment.  Consensus reads should therefore be aligned after, which should not be too expensive as likely there
    |are significantly fewer consensus reads than input raw reads.  Please see how best to use this tool within the
    |best-practice pipeline: https://github.com/fulcrumgenomics/fgbio/blob/main/docs/best-practice-consensus-pipeline.md
    |
    |Consensus reads have a number of additional optional tags set in the resulting BAM file.  The tag names follow
    |a pattern where the first letter (a, b or c) denotes that the tag applies to the first single strand consensus (a),
    |second single-strand consensus (b) or the final duplex consensus (c).  The second letter is intended to capture
    |the meaning of the tag (e.g. d=depth, m=min depth, e=errors/error-rate) and is upper case for values that are
    |one per read and lower case for values that are one per base.
    |
    |The tags break down into those that are single-valued per read:
    |
    |```
    |consensus depth      [aD,bD,cD] (int)  : the maximum depth of raw reads at any point in the consensus reads
    |consensus min depth  [aM,bM,cM] (int)  : the minimum depth of raw reads at any point in the consensus reads
    |consensus error rate [aE,bE,cE] (float): the fraction of bases in raw reads disagreeing with the final consensus calls
    |```
    |
    |And those that have a value per base (duplex values are not generated, but can be generated by summing):
    |
    |```
    |consensus depth  [ad,bd] (short[]): the count of bases contributing to each single-strand consensus read at each position
    |consensus errors [ae,be] (short[]): the count of bases from raw reads disagreeing with the final single-strand consensus base
    |consensus errors [ac,bc] (string): the single-strand consensus bases
    |consensus errors [aq,bq] (string): the single-strand consensus qualities
    |```
    |
    |The per base depths and error counts are both capped at 32,767. In all cases no-calls (Ns) and bases below the
    |min-input-base-quality are not counted in tag value calculations.
    |
    |[1] https://doi.org/10.1038/s41588-023-01376-0
  """,
  group = ClpGroups.Umi)
class CallCodecConsensusReads
(@arg(flag='i', doc="The input SAM or BAM file.") val input: PathToBam,
 @arg(flag='o', doc="Output SAM or BAM file to write consensus reads.") val output: PathToBam,
 @arg(flag='p', doc="The prefix all consensus read names") val readNamePrefix: Option[String] = None,
 @arg(flag='R', doc="The new read group ID for all the consensus reads.") val readGroupId: String = "A",
 @arg(flag='1', doc="The Phred-scaled error rate for an error prior to the UMIs being integrated.") val errorRatePreUmi: PhredScore = DefaultErrorRatePreUmi,
 @arg(flag='2', doc="The Phred-scaled error rate for an error post the UMIs have been integrated.") val errorRatePostUmi: PhredScore = DefaultErrorRatePostUmi,
 @arg(flag='m', doc="Ignore bases in raw reads that have Q below this value.") val minInputBaseQuality: PhredScore = DefaultMinInputBaseQuality,
 @arg(flag='S', doc="The sort order of the output, the same as the input if not given.") val sortOrder: Option[SamOrder] = None,
 @arg(flag='M', minElements=1, maxElements=3, doc="The minimum number of codec read pairs to form a consensus read.") val minReadsPerStrand: Int = 1,
 @arg(doc="""
            |The maximum number of reads to use when building a single-strand consensus. If more than this many reads are
            |present in a tag family, the family is randomly downsampled to exactly max-reads reads.
          """)
 val maxReadsPerStrand: Option[Int] = None,
 @arg(flag='d', doc="Minimum length of the duplex region (where R1 and R2 overlap).") val minDuplexLength: Int = 1,
 @arg(doc="The number of threads to use while consensus calling.") val threads: Int = 1,
) extends FgBioTool with LazyLogging {

  Io.assertReadable(input)
  Io.assertCanWriteFile(output)
  validate(errorRatePreUmi  > 0, "Phred-scaled error rate pre UMI must be > 0")
  validate(errorRatePostUmi > 0, "Phred-scaled error rate post UMI must be > 0")

  override def execute(): Unit = {
    val in = SamSource(input)
    UmiConsensusCaller.checkSortOrder(in.header, input, logger.warning, fail)

    // The output file is unmapped, so clear out the sequence dictionary & PGs
    val outHeader = UmiConsensusCaller.outputHeader(in.header, readGroupId, sortOrder)
    val out = SamWriter(output, outHeader, sort=sortOrder)

    val caller = new CodecConsensusCaller(
      readNamePrefix      = readNamePrefix.getOrElse(UmiConsensusCaller.makePrefixFromSamHeader(in.header)),
      readGroupId         = readGroupId,
      minInputBaseQuality = minInputBaseQuality,
      errorRatePreUmi     = errorRatePreUmi,
      errorRatePostUmi    = errorRatePostUmi,
      minReadsPerStrand   = minReadsPerStrand,
      maxReadsPerStrand   = maxReadsPerStrand.getOrElse(VanillaUmiConsensusCallerOptions.DefaultMaxReads),
      minDuplexLength     = minDuplexLength
    )
    val progress = ProgressLogger(logger, unit=1000000)
    val iterator = new ConsensusCallingIterator(in.iterator, caller, Some(progress), threads)
    out ++= iterator
    progress.logLast()

    in.safelyClose()
    out.close()
    caller.logStatistics(logger)
  }
}
