/*
 * The MIT License
 *
 * Copyright (c) 2025 Fulcrum Genomics LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package com.fulcrumgenomics.umi

import com.fulcrumgenomics.FgBioDef._
import com.fulcrumgenomics.bam.api.{SamOrder, SamSource, SamWriter}
import com.fulcrumgenomics.cmdline.{ClpGroups, FgBioTool}
import com.fulcrumgenomics.commons.io.Io
import com.fulcrumgenomics.commons.util.LazyLogging
import com.fulcrumgenomics.sopt._
import com.fulcrumgenomics.umi.VanillaUmiConsensusCallerOptions._
import com.fulcrumgenomics.util.NumericTypes.PhredScore
import com.fulcrumgenomics.util.{Metric, ProgressLogger}

@clp(description =
  """
    |Calls consensus sequences from reads generated from the the CODEC protocol. For more information on the CODEC
    |sequencing protocol and the resulting data please refer to Bae et al 2023[1].
    |
    |Prior to running this tool, reads must have been grouped with `GroupReadsByUmi` using the `adjacency` or `identity`
    |strategy (NOT `paired`).
    |
    |Reads from the same original duplex are collected, and the R1s and R2s assembled into single strand consensus
    |reads as described by `CallMolecularConsensusReads`.  Subsequently, a single consensus read is generated including
    |both any single-strand regions as well as the double-stranded region of the template.
    |
    |The consensus reads produced are unaligned, due to the difficulty and error-prone nature of inferring the consensus
    |alignment.  Consensus reads should therefore be aligned after, which should not be too expensive as likely there
    |are significantly fewer consensus reads than input raw reads.  Please see how best to use this tool within the
    |best-practice pipeline: https://github.com/fulcrumgenomics/fgbio/blob/main/docs/best-practice-consensus-pipeline.md
    |
    |Consensus reads have a number of additional optional tags set in the resulting BAM file.  The tag names follow
    |a pattern where the first letter (a, b or c) denotes that the tag applies to the first single strand consensus (a),
    |second single-strand consensus (b) or the final duplex consensus (c).  The second letter is intended to capture
    |the meaning of the tag (e.g. d=depth, m=min depth, e=errors/error-rate) and is upper case for values that are
    |one per read and lower case for values that are one per base.
    |
    |The tags break down into those that are single-valued per read:
    |
    |```
    |consensus depth      [aD,bD,cD] (int)  : the maximum depth of raw reads at any point in the consensus reads
    |consensus min depth  [aM,bM,cM] (int)  : the minimum depth of raw reads at any point in the consensus reads
    |consensus error rate [aE,bE,cE] (float): the fraction of bases in raw reads disagreeing with the final consensus calls
    |```
    |
    |And those that have a value per base (duplex values are not generated, but can be generated by summing):
    |
    |```
    |consensus depth  [ad,bd] (short[]): the count of bases contributing to each single-strand consensus read at each position
    |consensus errors [ae,be] (short[]): the count of bases from raw reads disagreeing with the final single-strand consensus base
    |consensus errors [ac,bc] (string): the single-strand consensus bases
    |consensus errors [aq,bq] (string): the single-strand consensus qualities
    |```
    |
    |The per base depths and error counts are both capped at 32,767. In all cases no-calls (Ns) and bases below the
    |min-input-base-quality are not counted in tag value calculations.
    |
    |[1] https://doi.org/10.1038/s41588-023-01376-0
  """,
  group = ClpGroups.Umi)
class CallCodecConsensusReads
(@arg(flag='i', doc="The input SAM or BAM file.") val input: PathToBam,
 @arg(flag='o', doc="Output SAM or BAM file to write consensus reads.") val output: PathToBam,
 @arg(flag='r', doc="Optional output SAM or BAM file to write reads not used.") val rejects: Option[PathToBam] = None,
 @arg(flag='s', doc="Optional output text file of key consensus calling statistics.") val stats: Option[FilePath] = None,
 @arg(flag='p', doc="The prefix all consensus read names") val readNamePrefix: Option[String] = None,
 @arg(flag='R', doc="The new read group ID for all the consensus reads.") val readGroupId: String = "A",
 @arg(flag='1', doc="The Phred-scaled error rate for an error prior to the UMIs being integrated.") val errorRatePreUmi: PhredScore = DefaultErrorRatePreUmi,
 @arg(flag='2', doc="The Phred-scaled error rate for an error post the UMIs have been integrated.") val errorRatePostUmi: PhredScore = DefaultErrorRatePostUmi,
 @arg(flag='m', doc="Ignore bases in raw reads that have Q below this value.") val minInputBaseQuality: PhredScore = DefaultMinInputBaseQuality,
 @arg(flag='S', doc="The sort order of the output, the same as the input if not given.") val sortOrder: Option[SamOrder] = None,
 @arg(flag='M', doc="The minimum number of codec read pairs to form a consensus read.") val minReadPairs: Int = 1,
 @arg(doc="""
            |The maximum number of reads to use when building a single-strand consensus. If more than this many reads are
            |present in a tag family, the family is randomly downsampled to exactly max-reads-pairs reads.
          """)
 val maxReadPairs: Option[Int] = None,
 @arg(flag='d', doc="Minimum length of the duplex region (where R1 and R2 overlap).") val minDuplexLength: Int = 1,
 @arg(flag='q', doc="Reduce quality scores in single stranded regions of the consensus read to the given quality.") val singleStrandQual: Option[PhredScore] = None,
 @arg(flag='Q', doc="Reduce the first and last `outer-bases-length` bases to the given quality.") val outerBasesQual: Option[PhredScore] = None,
 @arg(flag='O', doc="The number of bases at the start and end of the read to reduce quality over *if* `outer-bases-qual` is specified.") val outerBasesLength: Int = 5,
 @arg(flag='x', doc="Discard consensus reads where greater than this fraction of duplex bases disagree.") val maxDuplexDisagreementRate: Double = 1.0,
 @arg(flag='X', doc="Discard consensus reads where greater than this number of duplex bases disagree.") val maxDuplexDisagreements: Int = Int.MaxValue,
 @arg(doc="The number of threads to use while consensus calling.") val threads: Int = 1,
) extends FgBioTool with LazyLogging {

  Io.assertReadable(input)
  Io.assertCanWriteFile(output)
  rejects.foreach(Io.assertCanWriteFile(_))
  stats.foreach(Io.assertCanWriteFile(_))
  validate(errorRatePreUmi  > 0, "Phred-scaled error rate pre UMI must be > 0")
  validate(errorRatePostUmi > 0, "Phred-scaled error rate post UMI must be > 0")
  validate(minReadPairs >= 1, "min-read-pairs must be >= 1")
  validate(maxReadPairs.forall(_ >= minReadPairs), "max-read-pairs must be >= min-read-pairs")
  validate(minDuplexLength >= 1, "min-duplex-length must be >= 1")
  validate(outerBasesLength >= 0, "outer-bases-length must be >= 0")
  validate(outerBasesQual.forall(_ >= PhredScore.MinValue), s"outer-bases-qual must be >= ${PhredScore.MinValue}")
  validate(singleStrandQual.forall(_ >= PhredScore.MinValue), s"single-strand-qual must be >= ${PhredScore.MinValue}")

  override def execute(): Unit = {
    val in = SamSource(input)
    UmiConsensusCaller.checkSortOrder(in.header, input, logger.warning, fail)
    val rejectsWriter = rejects.map(r => SamWriter(r, in.header))

    // The output file is unmapped, so clear out the sequence dictionary & PGs
    val outHeader = UmiConsensusCaller.outputHeader(in.header, readGroupId, sortOrder)
    val out = SamWriter(output, outHeader, sort=sortOrder)

    val caller = new CodecConsensusCaller(
      readNamePrefix            = readNamePrefix.getOrElse(UmiConsensusCaller.makePrefixFromSamHeader(in.header)),
      readGroupId               = readGroupId,
      minInputBaseQuality       = minInputBaseQuality,
      errorRatePreUmi           = errorRatePreUmi,
      errorRatePostUmi          = errorRatePostUmi,
      minReadsPerStrand         = minReadPairs,
      maxReadsPerStrand         = maxReadPairs.getOrElse(VanillaUmiConsensusCallerOptions.DefaultMaxReads),
      minDuplexLength           = minDuplexLength,
      singleStrandQual          = singleStrandQual,
      outerBasesQual            = outerBasesQual,
      outerBasesLength          = outerBasesLength,
      maxDuplexDisagreements    = this.maxDuplexDisagreements,
      maxDuplexDisagreementRate = this.maxDuplexDisagreementRate,
      rejectsWriter             = rejectsWriter
    )
    val progress = ProgressLogger(logger, unit=1000000)
    val iterator = new ConsensusCallingIterator(in.iterator, caller, Some(progress), threads)
    out ++= iterator
    progress.logLast()

    in.safelyClose()
    out.close()
    rejectsWriter.foreach(_.close())

    caller.logStatistics(logger)
    stats.foreach { path => Metric.write(path, caller.statistics) }
  }
}
