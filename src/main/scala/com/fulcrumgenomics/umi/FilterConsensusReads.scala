/*
 * The MIT License
 *
 * Copyright (c) 2017 Fulcrum Genomics LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package com.fulcrumgenomics.umi

import com.fulcrumgenomics.FgBioDef._
import com.fulcrumgenomics.bam.Bams
import com.fulcrumgenomics.cmdline.{ClpGroups, FgBioTool}
import com.fulcrumgenomics.umi.VanillaUmiConsensusCallerOptions._
import com.fulcrumgenomics.util.{Io, ProgressLogger}
import dagr.commons.util.LazyLogging
import dagr.sopt.{arg, clp}
import htsjdk.samtools.SAMFileHeader.SortOrder
import htsjdk.samtools._
import htsjdk.samtools.reference.ReferenceSequenceFileWalker
import htsjdk.samtools.util.SequenceUtil

import scala.collection.JavaConversions.iterableAsScalaIterable

@clp(
  group = ClpGroups.Umi, description =
    """
      |Filters a BAM file of consensus reads generated by CallMolecularConsensusReads. Two kinds of
      |filtering are performed:
      |  1. Masking/filtering of individual bases in reads
      |  2. Filtering out of reads (i.e. not writing them to the output file)
      |
      |Base-level filtering/masking is only applied if per-base tags are present (see
      |CallMolecularConsensusReads for descriptions of these tags). Read-level filtering is always
      |applied.  When filtering reads, secondary alignments and supplementary records may be removed
      |independently if they fail one or more filters; if either R1 or R2 primary alignments fail a
      |filter then all records for the template will be filtered out.
      |
      |The filters applied are as follows:
      |  1. Reads with fewer than min-reads contributing reads are filtered out
      |  2. Reads with an average consensus error rate higher than max-read-error-rate are
      |     filtered out
      |  3. Bases with quality scores below min-base-quality are masked to Ns
      |  4. Bases with fewer than min-reads contributing raw reads are masked to Ns
      |  5. Bases with a consensus error rate (defined as the fraction of contributing reads that
      |     voted for a different base than the consensus call) higher than max-base-error-rate
      |     are masked to Ns
      |  6. Reads with a proportion of Ns higher than max-no-call-fraction *after* per-base
      |     filtering are filtered out.
      |
      |In order to correctly filter reads in or out by template, if the input BAM is not queryname
      |sorted or grouped it will be sorted into queryname order.  The resulting records are
      |coordinate sorted to efficiently correct the NM, UQ and MD tags, and the output BAM is
      |always written in coordinate order.
      |
      |The reverse-tags-per-base option controls whether per-base tags should be reversed before
      |being used on reads marked as being mapped to the negative strand.  This is necessary if
      |the reads have been mapped and the bases/quals reversed but the consensus tags have not.
      |If true, the tags written to the output BAM will be reversed where necesary in order to
      |line up with the bases and quals.
    """
)
class FilterConsensusReads
( @arg(flag="i", doc="The input SAM or BAM file of consensus reads.") val input: PathToBam,
  @arg(flag="o", doc="Output SAM or BAM file.") val output: PathToBam,
  @arg(flag="r", doc="Reference fasta file.") val ref: PathToFasta,
  @arg(flag="R", doc="Reverse [complement] per base tags on reverse strand reads.") val reversePerBaseTags: Boolean = true,
  @arg(flag="M", doc="The minimum number of reads supporting a consensus base/read.") val minReads: Int = DefaultMinReads,
  @arg(flag="E", doc="The maximum raw-read error rate across the entire consensus read.") val maxReadErrorRate: Double = 0.025,
  @arg(flag="N", doc="Mask (make 'N') consensus bases with quality less than this threshold.") val minBaseQuality: PhredScore = DefaultMinConsensusBaseQuality,
  @arg(flag="e", doc="The maximum error rate for a single consensus base.") val maxBaseErrorRate: Double = 0.1,
  @arg(flag="n", doc="Maximum fraction of no-calls in the read after filtering.") val maxNoCallFraction: Double = 0.2
) extends FgBioTool with LazyLogging {
  // Baseline input validation
  Io.assertReadable(input)
  Io.assertReadable(ref)
  Io.assertCanWriteFile(output)
  if (maxReadErrorRate < 0 && maxReadErrorRate > 1) fail("max-read-error-rate must be between 0 and 1.")
  if (maxBaseErrorRate < 0 && maxBaseErrorRate > 1) fail("max-base-error-rate must be between 0 and 1.")
  if (maxNoCallFraction < 0 && maxNoCallFraction > 1) fail("max-no-call-fraction must be between 0 and 1.")

  // Variables for tracking how many reads meet which fate
  private var totalReads:  Long = 0
  private var keptReads:   Long = 0
  private var maskedBases: Long = 0
  private var totalBases:  Long = 0

  // Case class to track results of filtering a single read
  private[umi] case class FilterResult(keepRead: Boolean, maskedBases: Int)

  override def execute(): Unit = {
    val in       = SamReaderFactory.make().open(input)
    val header   = in.getFileHeader.clone()
    header.setSortOrder(SortOrder.coordinate)
    val sorter    = Bams.sortingCollection(SortOrder.coordinate, header)
    val out       = new SAMFileWriterFactory().setCreateIndex(true).makeWriter(header, true, output.toFile, null)
    val progress1 = new ProgressLogger(logger, verb="Filtered and masked")

    // Go through the reads by template and do the filtering
    Bams.templateIterator(in).foreach { template =>
      val r1 = template.r1.getOrElse(throw new IllegalStateException(s"${template.name} had no R1."))
      if (r1.getReadPairedFlag) require(template.r2.isDefined, s"Paired read missing R2: ${template.name}")
      val primaryReadCount = if (template.r2.isDefined) 2 else 1
      totalReads += primaryReadCount

      val r1Result = filterRecord(r1)
      val r2Result = template.r2.map(filterRecord).getOrElse(FilterResult(keepRead=true, 0))

      if (r1Result.keepRead && r2Result.keepRead) {
        keptReads   += primaryReadCount
        totalBases  += r1.getReadLength + template.r2.map(_.getReadLength).getOrElse(0)
        maskedBases += r1Result.maskedBases + r2Result.maskedBases
        sorter.add(r1)
        progress1.record(r1)
        template.r2.foreach { r => sorter.add(r); progress1.record(r) }

        template.allSupplementaryAndSecondary.foreach { r =>
          val result = filterRecord(r)
          if (result.keepRead) {
            sorter.add(r)
            progress1.record(r)
          }
        }
      }
    }

    // Then iterate the reads in coordinate order and re-calculate key tags
    logger.info("Filtering complete; fixing tags and writing coordinate sorted reads.")
    val progress2 = new ProgressLogger(logger, verb="Wrote")
    val walker = new ReferenceSequenceFileWalker(ref.toFile)
    sorter.foreach { rec =>
      Bams.regenerateNmUqMdTags(rec, walker)
      out.addAlignment(rec)
      progress2.record(rec)
    }

    in.safelyClose()
    out.close()
    logger.info(f"Output ${keptReads}%,d of ${totalReads}%,d primary consensus reads.")
    logger.info(f"Masked ${maskedBases}%,d of ${totalBases}%,d bases in retained primary consensus reads.")
  }

  /**
    * Perform filtering on an individual read.
    *
    * @param  rec the read to filter
    * @return a tuple of (Boolean, Int) where the first value is true if the read should be kept
    *         and false if it should be filtered out, and the second value is the count of bases
    *         in the read that were masked to Ns as a result of per-base filtering
    */
  private[umi] def filterRecord(rec: SAMRecord): FilterResult = {
    val maxDepth = rec.getIntegerAttribute(ConsensusTags.PerRead.RawReadCount)
    val errRate = rec.getFloatAttribute(ConsensusTags.PerRead.RawReadErrorRate)
    if (maxDepth == null || errRate == null) fail(s"Read ${rec.getReadName} does not appear to have consensus calling tags present.")

    // Only bother looking at reads where per-read criteria are met
    if (maxDepth < this.minReads || errRate > maxReadErrorRate) {
      FilterResult(false, 0)
    }
    else {
      val bases = rec.getReadBases
      val quals = rec.getBaseQualities
      val depths = rec.getSignedShortArrayAttribute(ConsensusTags.PerBase.RawReadCount)
      val errors = rec.getSignedShortArrayAttribute(ConsensusTags.PerBase.RawReadErrors)

      if (rec.getReadNegativeStrandFlag && this.reversePerBaseTags) {
        reverse(depths)
        reverse(errors)
        rec.setAttribute(ConsensusTags.PerBase.RawReadCount, depths)
        rec.setAttribute(ConsensusTags.PerBase.RawReadErrors, errors)
      }

      val pb = depths != null && errors != null

      // Do the per-base masking
      var ns = 0
      var maskedBasesThisRead = 0
      forloop(from = 0, until = rec.getReadLength) { i =>
        if ((quals(i) < minBaseQuality) ||
          (pb && depths(i) < minReads) ||
          (pb && errors(i) / depths(i).toDouble > maxBaseErrorRate)) {
          bases(i) = 'N'
          maskedBasesThisRead += 1
        }

        // Count up the ns as we go, including those that were there previously, and those we just masked
        if (bases(i) == 'N') ns += 1
      }

      FilterResult(ns <= this.maxNoCallFraction * rec.getReadLength, maskedBasesThisRead)
    }
  }

  /** Reverses a short[]. */
  private def reverse(arr: Array[Short]): Unit = if (arr != null) {
    val lastIndex = arr.length - 1
    forloop (from=0, until=lastIndex/2) { i =>
      val tmp = arr(i)
      arr(i) = arr(lastIndex - i)
      arr(lastIndex - i) = tmp
    }
  }
}
