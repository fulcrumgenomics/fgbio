/*
 * The MIT License
 *
 * Copyright (c) 2018 Fulcrum Genomics LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package com.fulcrumgenomics.bam.identifyprimers

import java.io.File
import java.nio.file.{Files, Paths}
import java.util.concurrent.atomic.AtomicLong

import com.fulcrumgenomics.FgBioDef.{FilePath, PathToBam}
import com.fulcrumgenomics.alignment.{Aligner, AlignmentTask, BatchAligner, Mode => AlignmentMode}
import com.fulcrumgenomics.bam.api.{SamOrder, SamRecord, SamSource, SamWriter}
import com.fulcrumgenomics.bam.{Bams, Template}
import com.fulcrumgenomics.cmdline.{ClpGroups, FgBioTool}
import com.fulcrumgenomics.commons.CommonsDef.{unreachable, _}
import com.fulcrumgenomics.commons.collection.SelfClosingIterator
import com.fulcrumgenomics.commons.io.PathUtil
import com.fulcrumgenomics.commons.util.{LazyLogging, SimpleCounter}
import com.fulcrumgenomics.sopt.cmdline.ValidationException
import com.fulcrumgenomics.sopt.{arg, clp}
import com.fulcrumgenomics.util.{Io, Metric, ProgressLogger}


@clp(group=ClpGroups.SamOrBam, description=
  """
    |
    |Identifies primers that generate the reads in the input BAM file. For sequence data that is generated by targeted
    |PCR amplification, will identify the most likely primer for both the R1 and R2 ends of each template. Will detect
    |canonical (i.e. expected) primer pairings, unexpected primer pairings and primer-dimer products.
    |
    |## Primers
    |
    |The input primers file must be tab-seperated, and contain a header, and then one row per primer:
    |
    |  * pair_id - the unique identifier for the primer pair
    |  * primer_id - the unique identifier for the primer in a primer pair
    |  * sequence - the DNA sequence of the primer as ordered, including degenerate bases.
    |  * chr - the chromosome/contig
    |  * start - the start position (1-based)
    |  * end - the end position (1-based, inclusive)
    |  * strand - F/f/+ if the forward primer, R/r/- otherwise
    |
    |If forward is False, the sequence should be the reverse complement of the forward genomic strand.  Typically, the
    |forward primers will match the positive genomic strand and reverse primers will match the reverse complement of
    |the positive genomic strand.
    |
    |The primer file must contain headers, e.g:
    |
    |```
    |pair_id primer_id sequence chr  start   end     strand
    |1       1_1       GATTACA  chr1 1010873 1010894 +
    |1       1_2       ACATTAG  chr1 1011118 1011137 -
    |```
    |
    |Primers without mapping coordinates should have an empty `ref_name`.  The strand should still be given.
    |
    |Note: a canonical primer pair is the pair of primers with the same `pair_id`.  Other possible pairs are called
    |"non-canonical".
    |
    |Use the same `pair_id` to have `N` forward and `M` primers as part of a primer pair set (where either `N > 1` or
    |`M > 1).
    |
    |## Primer Matching
    |
    |Generally, the alignment position of a read is first used to find primers that overlap.  Next, the primer and read
    |sequence are compared based on mismatch-only alignment, then gapped alignment if necessary.
    |
    |### Paired-End Matching (5' only)
    |
    |If the input are paired-end reads, then the reads are further classified as follows for each read pair:
    |
    |1. If both R1 and R2 have primer matches on the 5' ends, classify as canonical if the primers are form a canonical
    |pair, otherwise non-canonical.
    |2. Otherwise, if only one read (R1 or R2) has a primer match, classify as a single primer match.
    |3. Otherwise, classify the reads as matching no primers.
    |
    |Note: when comparing a primer sequence to a read sequence, it "matches" if the two sequences are within at most
    |`--max-mismatches` to the assigned primers with at most `--max-mismatch-delta` difference between between number
    |of mismatches in the best and second best primer matches.
    |
    |## Matching Primers on the 3' End
    |
    |The `--three-prime` option can be used to also search the 3' end of every read for a primer sequence as follows:
    |
    |1. If a primer pair is identified using the 5' end, the expected paired primer is searched for at the 3' end.
    |2. Otherwise, assign a primer based on gapped alignment.
    |
    |When a primer match is found at both 5' and 3' ends of reads, the tool enforces that the 5' end of R1 and the 3'
    |end of R2 match the same primer, and vice versa.
    |
    |### Unmapped Data or Primers without Mappings
    |
    |If no reference is given or mapping information is not available, matching using mapping locations is skipped.
    |
    |### Speeding Up Alignment
    |
    |Install [the ksw executable](https://github.com/nh13/ksw) manually or via conda (`conda install -c bioconda ksw`)
    |and supply the path to the `ksw` executable via `--ksw`.
  """)
class IdentifyPrimers
(@arg(flag='i', doc="Input BAM file.")  val input: PathToBam,
 @arg(flag='p', doc="File containing information about the primer pairs.") val primerPairs: FilePath,
 @arg(flag='o', doc="Output BAM file.") val output: PathToBam,
 @arg(flag='m', doc="Path prefix for the metrics files.") val metrics: PathPrefix,
 @arg(flag='S', doc="Match to primer locations +/- this many bases.") val slop: Int = 5,
 @arg(flag='3', doc="Search for primers on the 3' end of each read as well (5' only by default).") val threePrime: Boolean = false,
 @arg(          doc="Maximum per-base mismatch rate for a primer to be considered a match.") val maxMismatchRate: Double = 0.05,
 @arg(          doc="The minimum per-base alignment score rate for gapped alignment for a primer to be considered a match. " +
                    "This is the total score divided by the primer length.") val minAlignmentScoreRate: Double = 0.5,
 @arg(          doc="The match score to use for aligning to primer sequences (must be >= 0).") val matchScore: Int = 1,
 @arg(          doc="The mismatch score to use for aligning to primer sequences (must be <= 0).") val mismatchScore: Int = -4,
 @arg(          doc="The gap open score to use for aligning to primer sequences (must be <= 0).") val gapOpen: Int = -6,
 @arg(          doc="The gap extension score to use for aligning to primer sequences (must be <= 0).") val gapExtend: Int = -1,
 @arg(flag='t', doc="The number of threads to use.") val threads: Int = 1,
 @arg(          doc="Skip gapped-alignment matching") val skipGappedAlignment: Boolean = false,
 @arg(          doc="Path to the ksw aligner.") val ksw: Option[String] = None,
 @arg(flag='k', doc="Skip ungapped alignment if no kmer of this length is common between any primer and a given read.") val ungappedKmerLength: Option[Int] = None,
 @arg(flag='K', doc="Skip gapped alignment if no kmer of this length is common between any primer and a given read.") val gappedKmerLength: Option[Int] = None,
 @arg(          doc="Allow multiple primers on the same strand to have the same `pair_id`.") val multiPrimerPairs: Boolean = false
) extends FgBioTool with LazyLogging {

  /** The maximum number of templates in memory. */
  private val maxTemplatesInRam: Option[Int] = None

  /** The number of templates to process at a time per thread. */
  private val templatesPerThread: Int = 5000

  // TODO: tim: this branch will also get triggered if the user typos, e.g. /usr/locla/bin/ksw, and that's going to be very confusing. Could you instead just try executing the executable given and see if it works?
  private val kswExecutable: Option[FilePath] = this.ksw.map(Paths.get(_)).flatMap {
    case p if Files.exists(p)                  => Some(p)
    case name if name.contains(File.separator) =>
      throw new ValidationException(s"Path to the ksw executable does not exist: $ksw")
    case name                                  =>
      // try the system path
      val path = System.getenv("PATH")
      validate(path != null, s"Searching for the ksw executable '$ksw' on the PATH, but the PATH environment variable was not defined.")
      path.split(File.pathSeparatorChar)
        .view
        .map(PathUtil.pathTo(_))
        .map(p => p.resolve(name)).find(ex => Files.exists(ex))
        .orElse {
          throw new ValidationException(s"Is the path to the ksw executable mis-typed? Could not find ksw executable ${ksw} in PATH: $path")
        }
  }

  Io.assertReadable(input)
  Io.assertCanWriteFile(output)
  Io.assertCanWriteFile(metrics)
  kswExecutable.foreach(Io.assertReadable)

  validate(maxMismatchRate >= 0, "--max-mismatches must be >= 0")
  validate(matchScore >= 0,       "--match-score must be >= 0")
  validate(mismatchScore <= 0,    "--mismatch-score must be <= 0")
  validate(gapOpen <= 0,          "--gap-open must be <= 0")
  validate(gapExtend <= 0,        "--gap-extend must be <= 0")
  validate(minAlignmentScoreRate >= 0, "--min-alignment-score-rate must be >= 0")
  maxTemplatesInRam.foreach { m => validate(templatesPerThread < m, "--max-templates-in-ram must be greater than or equal to --templates-per-thread")}


  private val requireSameStrand: Boolean = false // FIXME: command line option

  private val (locationBasedMatcher, ungappedBasedMatcher, gappedBasedMatcher) = {
    val primers  = Primer.read(this.primerPairs, multiPrimerPairs = multiPrimerPairs).toIndexedSeq
    val location = new LocationBasedPrimerMatcher(primers.filter(_.positiveStrand), slop, requireSameStrand, maxMismatchRate)
    val ungapped = new UngappedAlignmentBasedPrimerMatcher(primers, slop, requireSameStrand, maxMismatchRate, ungappedKmerLength)
    val gapped   = {
      val aligner: Aligner = Aligner(matchScore = matchScore, mismatchScore = mismatchScore, gapOpen = gapOpen, gapExtend = gapExtend, mode = AlignmentMode.Glocal)
      new GappedAlignmentBasedPrimerMatcher(primers, slop, requireSameStrand, aligner, minAlignmentScoreRate, gappedKmerLength)
    }
    (location, ungapped, gapped)
  }

  val numAlignments: AtomicLong = new AtomicLong(0)

  private val PrimerPairMatchTypeTag: String = "pp"
  private val PrimerInfoForwardTag: String   = "pf"
  private val PrimerInfoReverseTag: String   = "pr"
  private val NoPrimerMatchInfo: String      = "none"
  private val comments: Seq[String]          = {
    Seq(
      "The pf/pr tags store the primer match metadata for the forward and reverse strand respectively.",
      "The pf/pr tags are formatted as follow: <pair_id>,<primer_id>,<refName>:<start>-<end>,<strand>,<5-prime-offset>,<match-type>,<match-type-info>.",
      s"The match-type is 'location', 'mismatch', or 'aligmnent' based on if the match was found using the location, mismatch-based alignment, or gapped-alignment.",
      s"The pp tag is either 'canonical', 'non-canonical', 'single', or '$NoPrimerMatchInfo' based on if the matches for the primer pair agree, disagree, or are missing."
    )
  }

  override def execute(): Unit = {
    this.kswExecutable match {
      case Some(p) => logger.info(s"Using ksw aligner: $p")
      case None    => logger.info("Using the internal aligner; install ksw for faster operation.")
    }
    val metricCounter = new SimpleCounter[TemplateTypeMetric]()

    // Group the reads by template
    val in: SamSource = SamSource(this.input)
    val iterator: Iterator[Template] = Bams.templateIterator(in)

    // NB: Add comments explaining tags in the output writer
    val (out: SamWriter, programGroupId: Option[String]) = {
      val header = {
        val h = in.header.clone()
        comments.foreach { comment => h.addComment(comment) }
        h
      }
      val pgId   = this.toolInfo.map { info => info.applyTo(header) }
      val writer = SamWriter(path = output, header = header, sort = SamOrder(in.header))
      (writer, pgId)
    }

    // We take the input records, and batch them into `majorBatchSize` number of records.  For each major-batch, we
    // split those into `templatesPerThread` sub-batches.  Each sub-batch is processed by a single thread.  We process
    // each major-batch serially, meaning we wait for one major-batch to complete before moving onto the next one.  This
    // is so we don't have to read all records into memory to parallize.  We set the `majorBatchSize` to have more
    // sub-batches than just `templatesPerThread * threads` so that we can more efficiently utlize the available threads.
    val majorBatchSize  = templatesPerThread * threads * 4
    val readingProgress = ProgressLogger(this.logger, verb="read", unit=5e4.toInt)

    // Batch templates to process them in individual threads.
    val outputIterator: Iterator[Seq[Template]] = if (threads > 1) {
      logger.info(f"Batching $majorBatchSize%,d templates with $templatesPerThread%,d templates per thread.")

      import com.fulcrumgenomics.commons.CommonsDef.ParSupport
      // Developer Note: Iterator does not support parallel operations, so we need to group together records into a
      // [[List]] or [[Seq]].  A fixed number of records are grouped to reduce memory overhead.
      iterator
        .grouped(majorBatchSize)
        .flatMap { templates =>
          templates
            .grouped(templatesPerThread)
            .toStream
            .parWith(threads, fifo = false)
            .map { templates => processBatch(templates, metricCounter, readingProgress) }
            .seq // ensures that the only parallelism is processBatch
            .toIterator
        }
    }
    else {
      val aligner = newAligner
      logger.info(f"Batching $templatesPerThread%,d templates.")
      val iter = iterator
        .grouped(templatesPerThread)
        .map { templates => processBatch(templates, metricCounter, readingProgress, Some(aligner)) }
      new SelfClosingIterator[Seq[Template]](iter, () => aligner.close())
    }

    // Write the results
    val writingProgress = ProgressLogger(this.logger, "written", unit=1000000)
    outputIterator
      .flatMap(_.flatMap(_.allReads))
      .foreach { rec =>
        programGroupId.foreach { pgId => rec("PG") = pgId }
        writingProgress.record(rec)
        out += rec
      }

    val rate = numAlignments.get() / readingProgress.getElapsedSeconds.toDouble
    logger.info(f"Performed ${numAlignments.get()}%,d gapped alignments in total ($rate%,.2f alignments/second).")
    logger.info(f"Wrote ${readingProgress.getCount}%,d records.")

    in.safelyClose()
    out.close()

    // Create the [[TemplateTypeMetric]]
    val templateTypeMetrics = TemplateTypeMetric.metricsFrom(metricCounter)

    // Write metrics
    // Detailed metrics
    Metric.write(PathUtil.pathTo(this.metrics + ".detailed.txt"), templateTypeMetrics)
    // Summary metrics
    Metric.write(PathUtil.pathTo(this.metrics + ".summary.txt"), IdentifyPrimersMetric(templateTypeMetrics))
  }

  /** Creates a new [[BatchAligner]]. */
  private def newAligner: BatchAligner[Primer, SamRecordAlignable] = {
    BatchAligner(matchScore, mismatchScore, gapOpen, gapExtend, AlignmentMode.Glocal, this.kswExecutable)
  }

  // NB: batching alignment inputs to the aligner (i.e. ksw) is empirically faster than given them all or just one at a time.
  private def getAlignmentResults(alignmentTasks: Seq[AlignmentTask[Primer, SamRecordAlignable]],
                                  aligner: BatchAligner[Primer, SamRecordAlignable]): Option[PrimerMatch] = {
    case class PrimerAndScore(primer: Primer, score: Int)

    // Get the alignment results
    val alignmentResults: Seq[PrimerAndScore] = alignmentTasks.toIterator.zip(aligner.iterator)
      // Keep results that meet the minimum score and align with a minimum # of query bases
      .filter { case (alignmentInput, alignmentResult) =>
        val minQueryEnd = alignmentInput.queryLength - slop
        val alignmentScoreRate = alignmentResult.score * alignmentInput.query.length.toDouble
        alignmentScoreRate >= minAlignmentScoreRate && alignmentResult.queryEnd >= minQueryEnd
      }
      // now just keep the primer and score
      .map { case (alignmentInput, alignmentResult) => PrimerAndScore(alignmentInput.query, alignmentResult.score) }
      // get the best two alignment results by score
      .maxNBy(n = 2, _.score)

    // Create a primer match if alignments were found (i.e. a Option[PrimerMatch])
    alignmentResults match {
      case Seq()               => None
      case Seq(best)           =>
        val secondBestScore = (minAlignmentScoreRate * best.primer.length).toInt
        Some(GappedAlignmentPrimerMatch(primer = best.primer, score = best.score, secondBestScore = secondBestScore))
      case Seq(best, nextBest) => Some(GappedAlignmentPrimerMatch(primer = best.primer, score = best.score, secondBestScore = nextBest.score))
      case _                   => unreachable("Should have returned at most two items.")
    }
  }

  /** Matches the read based on location, then ungapped alignment.  If no match was found, return a list of alignment tasks. */
  private def toPrimerMatchOrAlignmentTasks(rec: SamRecord): Either[PrimerMatch, Seq[AlignmentTask[Primer, SamRecordAlignable]]] = {
    locationBasedMatcher.find(rec).orElse { ungappedBasedMatcher.find(rec) } match {
      case Some(pm) => Left(pm)
      case None     => Right(gappedBasedMatcher.toAlignmentTasks(rec))
    }
  }

  /** Processes a single batch of templates. */
  def processBatch(templates: Seq[Template],
                   metricCounter: SimpleCounter[TemplateTypeMetric],
                   progress: ProgressLogger,
                   batchAligner: Option[BatchAligner[Primer, SamRecordAlignable]] = None): Seq[Template] = {

    val counter = new SimpleCounter[TemplateTypeMetric]()
    val aligner = batchAligner.getOrElse(newAligner)

    // reset the provided aligner
    batchAligner.foreach(_.reset())

    val templateMatchOptions = templates.toIterator.map { template =>

      // match based on location, then ungapped alignment, and if no match was found, then return the alignment tasks
      val r1MatchOrTasks = template.r1.map { r => toPrimerMatchOrAlignmentTasks(r) }
      val r2MatchOrTasks = template.r2.map { r => toPrimerMatchOrAlignmentTasks(r) }

      // add any alignment tasks
      Seq(r1MatchOrTasks, r2MatchOrTasks).flatten.foreach {
        case Right(alignmentTasks) => alignmentTasks.foreach(t => aligner.append(t))
        case Left(_)               => Unit
      }

      (template, r1MatchOrTasks, r2MatchOrTasks)
    }

    // run through the match options, retrieving any alignment tasks that were performed
    templateMatchOptions.foreach { case (template, r1MatchOrTasks, r2MatchOrTasks) =>
      // get the final primer match, if any.  We must retrieve results from the aligner if we sent tasks
      val r1Match = r1MatchOrTasks.flatMap {
        case Left(pm)              => Some(pm)
        case Right(alignmentTasks) => getAlignmentResults(alignmentTasks, aligner)
      }
      val r2Match = r2MatchOrTasks.flatMap {
        case Left(pm)              => Some(pm)
        case Right(alignmentTasks) => getAlignmentResults(alignmentTasks, aligner)
      }

      // add the three prime matching
      val r1ThreePrimeMatch = template.r1.flatMap { r1 => matchThreePrime(r1, r1Match, fwdMatch=true) }
      val r2ThreePrimeMatch = template.r2.flatMap { r2 => matchThreePrime(r2, r2Match, fwdMatch=false) }

      // Get information about the matches
      val templateTypes = (template.r1, template.r2) match {
        case (Some(r1), Some(r2)) =>
          val rType = (r1.mapped, r2.mapped) match {
            case (true, true)   => TemplateType.MappedPair
            case (true, false)  => TemplateType.Unpaired
            case (false, true)  => TemplateType.Unpaired
            case (false, false) => TemplateType.UnmappedPair
          }
          val mType = formatPair(r1, r2, r1Match, r2Match, r1ThreePrimeMatch, r2ThreePrimeMatch)
          TemplateTypeMetric(rType, r1.isFrPair, mType, r1Match, r2Match)
        case (Some(r1), None) =>
          require(!r1.paired, s"Found paired read but missing R2 for ${r1.name}")
          val rType = if (r1.mapped) TemplateType.MappedFragment else TemplateType.UnmappedFragment
          val mType = formatFragment(r1, r1Match, r1ThreePrimeMatch)
          TemplateTypeMetric(rType, r1.isFrPair, mType, r1Match, r2Match)
        case _ =>
          throw new IllegalStateException(s"Template did not have an R1: ${template.name}")
      }

      counter.count(templateTypes)
    }

    require(aligner.numAdded == aligner.numRetrieved, s"added: ${aligner.numAdded} alignments: ${aligner.numRetrieved}")
    require(aligner.numAvailable == 0, s"Found alignments available: ${aligner.numAvailable}")

    if (batchAligner.isEmpty) aligner.close()

    numAlignments.addAndGet(aligner.numRetrieved)
    metricCounter.synchronized {
      metricCounter += counter
      templates.flatMap(_.allReads).foreach { rec =>
        if (progress.record(rec)) {
          val rate = numAlignments.get() / progress.getElapsedSeconds.toDouble
          logger.info(f"Performed ${numAlignments.get()}%,d gapped alignments so far ($rate%,.2f alignments/second).")
        }
      }
    }

    templates
  }


  private def matchThreePrime(rec: SamRecord, fivePrimeMatch: Option[PrimerMatch], fwdMatch: Boolean): Option[PrimerMatch] = if (!threePrime) None else {
    // FIXME
    throw new NotImplementedError("Three-prime matching currently not supported, but is planned.")
  }

  /** Adds tags to the records based on the primer matching results. */
  private def formatPair(r1: SamRecord,
                         r2: SamRecord,
                         r1FivePrimeMatch: Option[PrimerMatch],
                         r2FivePrimeMatch: Option[PrimerMatch],
                         r1ThreePrimeMatch: Option[PrimerMatch],
                         r2ThreePrimeMatch: Option[PrimerMatch]): PrimerPairMatchType = {
    import PrimerPairMatchType._

    // Set the primer pair match type
    val matchType: PrimerPairMatchType = (r1FivePrimeMatch, r2FivePrimeMatch) match {
      case (Some(fwd), Some(rev))            =>
        if (fwd.primer.pair_id == rev.primer.pair_id && fwd.primer.positiveStrand == rev.primer.negativeStrand) Canonical else NonCanonical
      case (Some(_), None) | (None, Some(_)) => Single
      case _                                 => NoMatch
    }
    r1(PrimerPairMatchTypeTag) = matchType.toString

    // Set the per-primer/per-read match metadata
    val forwardInfo = r1FivePrimeMatch.map(_.info(r1, forward = true)).getOrElse(NoPrimerMatchInfo)
    val reverseInfo = r2FivePrimeMatch.map(_.info(r2, forward = false)).getOrElse(NoPrimerMatchInfo)
    Seq(r1, r2).foreach { rec =>
      rec(PrimerInfoForwardTag) = forwardInfo
      rec(PrimerInfoReverseTag) = reverseInfo
    }

    // TODO: three prime

    matchType
  }

  /** Adds tags to the record based on the primer matching results. */
  private def formatFragment(frag: SamRecord, fragFivePrimeMatch: Option[PrimerMatch], fragThreePrimeMatch: Option[PrimerMatch]): PrimerPairMatchType = {
    import PrimerPairMatchType._
    val forwardInfo = fragFivePrimeMatch.map(_.info(frag, forward = true)).getOrElse(NoPrimerMatchInfo)

    val matchType: PrimerPairMatchType = fragFivePrimeMatch match {
      case Some(_) => Single
      case None    => NoMatch
    }

    frag(PrimerPairMatchTypeTag) = matchType.toString
    frag(PrimerInfoForwardTag)   = forwardInfo
    frag(PrimerInfoReverseTag)   = NoPrimerMatchInfo

    // TODO: three prime

    matchType
  }
}



object IdentifyPrimers {

  // FIXME: remove after this merges: https://github.com/fulcrumgenomics/commons/pull/34
  /** An implicit class that adds support for getting the maximum two values, if they exist. */
  implicit class MaxTwoBy[A](values: Iterator[A]) {
    def maxTwoBy[B](f: A => B)(implicit cmp: Ordering[B]): (Option[A], Option[A]) = {
      var best: Option[A] = None
      var bestValue: Option[B] = None
      var nextBest: Option[A] = None
      var nextBestValue: Option[B] = None

      values.foreach { cur =>
        val curValue = f(cur)

        if (bestValue.forall(v => cmp.lt(v, curValue))) {
          best = Some(cur)
          bestValue = Some(curValue)
        }
        else if (nextBestValue.forall(v => cmp.lt(v, curValue))) {
          nextBest = Some(cur)
          nextBestValue = Some(curValue)
        }
      }

      (best, nextBest)
    }
  }

}