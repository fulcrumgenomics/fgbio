/*
 * The MIT License
 *
 * Copyright (c) 2018 Fulcrum Genomics LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package com.fulcrumgenomics.bam

import java.io.File
import java.nio.file.{Files, Paths}
import java.util.concurrent.{ArrayBlockingQueue, BlockingQueue}
import java.util.concurrent.atomic.AtomicLong

import com.fulcrumgenomics.FgBioDef.{FgBioEnum, FilePath, PathToBam, forloop}
import com.fulcrumgenomics.alignment.{Alignable, Aligner, Alignment, AlignmentTask, BatchAligner, Mode => AlignmentMode}
import com.fulcrumgenomics.bam.api.{SamOrder, SamRecord, SamSource, SamWriter}
import com.fulcrumgenomics.cmdline.{ClpGroups, FgBioTool}
import com.fulcrumgenomics.commons.CommonsDef.{javaIteratorAsScalaIterator, unreachable, _}
import com.fulcrumgenomics.commons.io.PathUtil
import com.fulcrumgenomics.commons.reflect.ReflectionUtil
import com.fulcrumgenomics.commons.util.{DelimitedDataParser, LazyLogging, SimpleCounter}
import com.fulcrumgenomics.sopt.cmdline.ValidationException
import com.fulcrumgenomics.sopt.{arg, clp}
import com.fulcrumgenomics.util.{Io, Metric, ProgressLogger}
import enumeratum.EnumEntry
import htsjdk.samtools.util.{Interval, Locatable, OverlapDetector, SequenceUtil}

import scala.collection.immutable
import scala.reflect._
import scala.reflect.runtime.universe._
import scala.reflect.runtime.{universe => ru}

// TODO: is it valid to have >2 primers with the same pair_id?
// - is 1 fwd N rev ok? 1 x N?
// - is N fwd M rev ok? N X M?

@clp(group=ClpGroups.SamOrBam, description=
  """
    |
    |Identifies primers that generate the reads in the input BAM file. For sequence data that is generated by targeted
    |PCR amplification, will identify the most likely primer for both the R1 and R2 ends of each template. Will detect
    |canonical (i.e. expected) primer pairings, unexpected primer pairings and primer-dimer products.
    |
    |## Primers
    |
    |The input primers file must be tab-seperated, and contain a header, and then one row per primer:
    |
    |  * pair_id - the unique identifier for the primer pair
    |  * primer_id - the unique identifier for the primer in a primer pair
    |  * sequence - the DNA sequence of the primer as ordered, including degenerate bases.
    |  * chr - the chromosome/contig
    |  * start - the start position (1-based)
    |  * end - the end position (1-based, inclusive)
    |  * forward - F/f/+ if the forward primer, R/r/- otherwise
    |
    |If forward is False, the sequence should be the reverse complement of the forward genomic strand.  Typically, the
    |forward primers will match the positive genomic strand and reverse primers will match the reverse complement of
    |the positive genomic strand.
    |
    |The primer file must contain headers, e.g:
    |
    |```
    |pair_id primer_id sequence chr  start   end     strand
    |1       1_1       GATTACA  chr1 1010873 1010894 +
    |1       1_2       ACATTAG  chr1 1011118 1011137 -
    |```
    |
    |If no mapping information is available for primers, use a different chromosome/start/end combination for each primer
    |such that no alignment in the input reads overlap.  This can be acheived using "dummy" as your chromosome name.
    |
    |Note: a canonical primer pair is the pair of primers with the same `pair_id`.  Other possible pairs are called
    |"non-canonical".
    |
    |## Primer Matching
    |
    |Generally, the alignment position of a read is first used to find primers that overlap.  Next, the primer and read
    |sequence are compared based on mismatch-only alignment, then fully-gapped alignment if necessary.
    |
    |### Paired-End Matching (5' only)
    |
    |If the input are paired-end reads, then the reads are further classified as follows for each read pair:
    |
    |1. If both R1 and R2 have primer matches on the 5' ends, classify as canonical if the primers are form a canonical
    |pair, otherwise non-canonical.
    |2. Otherwise, if only one read (R1 or R2) has a primer match, classify as a single primer match.
    |3. Otherwise, classify the reads as matching no primers.
    |
    |Note: when comparing a primer sequence to a read sequence, it "matches" if the two sequences are within at most
    |`--max-mismatches` to the assigned primers with at most `--max-mismatch-delta` difference between between number
    |of mismatches in the best and second best primer matches.
    |
    |## Matching Primers on the 3' End
    |
    |The `--three-prime` option can be used to also search the 3' end of every read for a primer sequence as follows:
    |
    |1. If a primer pair is identified using the 5' end, the expected paired primer is searched for at the 3' end.
    |2. Otherwise, assign a primer based on fully-gapped alignment.
    |
    |When a primer match is found at both 5' and 3' ends of reads, the tool enforces that the 5' end of R1 and the 3'
    |end of R2 match the same primer, and vice versa.
    |
    |### Unmapped Data or Primers without Mappings
    |
    |If no reference is given or mapping information is not available, matching using mapping locations is skipped.
    |
    |### Speeding Up Alignment
    |
    |Install [the ksw executable](https://github.com/nh13/ksw) manually or via conda (`conda install -c bioconda ksw`)
    |and supply the path to the `ksw` executable via `--ksw`.
  """)
class IdentifyPrimers
(@arg(flag='i', doc="Input BAM file.")  val input: PathToBam,
 @arg(flag='p', doc="File containing information about the primers.") val primers: FilePath,
 @arg(flag='o', doc="Output BAM file.") val output: PathToBam,
 @arg(flag='m', doc="Path prefix for the metrics files.") val metrics: PathPrefix,
 @arg(flag='S', doc="Match to primer locations +/- this many bases.") val slop: Int = 5,
 @arg(flag='3', doc="Search for primers on the 3' end of each read as well (5' only by default).") val threePrime: Boolean = false,
 @arg(          doc="Maximum per-base mismatch rate for a primer to be considered a match.") val maxMismatchRate: Double = 0.05,
 @arg(          doc="The minimum per-base alignment score rate for fully gapped alignment for a primer to be considered a match. " +
                    "This is the total score divided by the primer length.") val minAlignmentScoreRate: Double = 0.5,
 @arg(          doc="The match score to use for aligning to primer sequences (must be >= 0).") val matchScore: Int = 1,
 @arg(          doc="The mismatch score to use for aligning to primer sequences (must be <= 0).") val mismatchScore: Int = -4,
 @arg(          doc="The gap open score to use for aligning to primer sequences (must be <= 0).") val gapOpen: Int = -6,
 @arg(          doc="The gap extension score to use for aligning to primer sequences (must be <= 0).") val gapExtend: Int = -1,
 @arg(flag='t', doc="The number of threads to use.") val threads: Int = 1,
 @arg(          doc="Skip full-alignment matching") val skipFullAlignment: Boolean = false,
 @arg(          doc="Path to the ksw aligner.") val ksw: Option[String] = None,
) extends FgBioTool with LazyLogging {

  import IdentifyPrimers._

  /** The maximum number of templates in memory. */
  private val maxTemplatesInRam: Option[Int] = None

  /** The number of templates to process at a time per thread. */
  private val templatesPerThread: Int = 1000

  // TODO: tim: this branch will also get triggered if the user typos, e.g. /usr/locla/bin/ksw, and that's going to be very confusing. Could you instead just try executing the executable given and see if it works?
  private val kswExecutable: Option[FilePath] = this.ksw.map(Paths.get(_)).flatMap {
    case p if Files.exists(p)                  => Some(p)
    case name if name.contains(File.separator) =>
      throw new ValidationException(s"Path to the ksw executable does not exist: $ksw")
    case name                                  =>
      // try the system path
      val path = System.getenv("PATH")
      validate(path != null, s"Searching for the ksw executable '$ksw' on the PATH, but the PATH environment variable was not defined.")
      path.split(File.pathSeparatorChar)
        .view
        .map(PathUtil.pathTo(_))
        .map(p => p.resolve(name)).find(ex => Files.exists(ex))
        .orElse {
          throw new ValidationException(s"Is the path to the ksw executable mis-typed? Could not find ksw executable ${ksw} in PATH: $path")
        }
  }

  Io.assertReadable(input)
  Io.assertCanWriteFile(output)
  Io.assertCanWriteFile(metrics)
  kswExecutable.foreach(Io.assertReadable)

  validate(maxMismatchRate >= 0, "--max-mismatches must be >= 0")
  validate(matchScore >= 0,       "--match-score must be >= 0")
  validate(mismatchScore <= 0,    "--mismatch-score must be <= 0")
  validate(gapOpen <= 0,          "--gap-open must be <= 0")
  validate(gapExtend <= 0,        "--gap-extend must be <= 0")
  validate(minAlignmentScoreRate >= 0, "--min-alignment-score-rate must be >= 0")
  maxTemplatesInRam.foreach { m => validate(templatesPerThread < m, "--max-templates-in-ram must be greater than or equal to --templates-per-thread")}

  private val aligner: Aligner = Aligner(matchScore = matchScore, mismatchScore = mismatchScore, gapOpen = gapOpen, gapExtend = gapExtend, mode = AlignmentMode.Glocal)

  private val (fwdMatcher, revMatcher) = PrimerMatcher.build(
    path                  = this.primers,
    aligner               = aligner,
    slop                  = slop,
    maxMismatchRate       = maxMismatchRate,
    minAlignmentScoreRate = minAlignmentScoreRate,
    withFullAlignment     = !skipFullAlignment,
    revComp               = true
  )

  val numAlignments: AtomicLong = new AtomicLong(0)

  private val PrimerPairMatchTypeTag: String = "pp"
  private val PrimerInfoForwardTag: String   = "pf"
  private val PrimerInfoReverseTag: String   = "pr"
  private val NoPrimerMatchInfo: String      = "none"
  private val comments: Seq[String]          = {
    Seq(
      "The pf/pr tags store the primer match metadata for the forward and reverse strand respectively.",
      "The pf/pr tags are formatted as follow: <pair_id>,<primer_id>,<refName>:<start>-<end>,<strand>,<5-prime-offset>,<match-type>,<match-type-info>.",
      s"The match-type is 'location', 'mismatch', or 'aligmnent' based on if the match was found using the location, mismatch-based alignment, or full-alignment.",
      s"The pp tag is either 'canonical', 'non-canonical', 'single', or '$NoPrimerMatchInfo' based on if the matches for the primer pair agree, disagree, or are missing."
    )
  }

  override def execute(): Unit = {
    this.kswExecutable match {
      case Some(p) => logger.info(s"Using ksw aligner: $p")
      case None    => logger.info("Using the internal aligner; install ksw for faster operation.")
    }
    val metricCounter = new SimpleCounter[TemplateTypeMetric]()

    // Group the reads by template
    val in: SamSource = SamSource(this.input)
    val iterator: Iterator[Template] = Bams.templateIterator(in)

    // NB: Add comments explaining tags in the output writer
    val out: SamWriter = {
      val header = {
        val h = in.header.clone()
        comments.foreach { comment => h.addComment(comment) }
        h
      }
      SamWriter(path = output, header = header, sort = SamOrder(in.header))
    }

    // We take the input records, and batch them into `majorBatchSize` number of records.  For each major-batch, we
    // split those into `templatesPerThread` sub-batches.  Each sub-batch is processed by a single thread.  We process
    // each major-batch serially, meaning we wait for one major-batch to complete before moving onto the next one.  This
    // is so we don't have to read all records into memory to parallize.  We set the `majorBatchSize` to have more
    // sub-batches than just `templatesPerThread * threads` so that we can more efficiently utlize the available threads.
    val majorBatchSize  = templatesPerThread * threads * 16
    val readingProgress = ProgressLogger(this.logger, verb="read", unit=50000)

    // Batch templates to process them in individual threads.
    val outputIterator: Iterator[Seq[Template]] = if (threads > 1) {
      logger.info(f"Batching $majorBatchSize%,d templates with $templatesPerThread%,d templates per thread.")

      import com.fulcrumgenomics.commons.CommonsDef.ParSupport
      // Developer Note: Iterator does not support parallel operations, so we need to group together records into a
      // [[List]] or [[Seq]].  A fixed number of records are grouped to reduce memory overhead.
      iterator
        .grouped(majorBatchSize)
        .flatMap { templates =>
          templates
            .grouped(templatesPerThread)
            .toStream
            .parWith(threads, fifo = false)
            .map { templates => processBatch(templates, metricCounter, readingProgress) }
            .seq // ensures that the only parallelism is processBatch
            .toIterator
        }
    }
    else {
      logger.info(f"Batching $templatesPerThread%,d templates.")
      iterator
        .grouped(templatesPerThread)
        .map { templates => processBatch(templates, metricCounter, readingProgress) }
    }

    // Write the results
    val writingProgress = ProgressLogger(this.logger, "written", unit=1000000)
    outputIterator
      .flatMap(_.flatMap(_.allReads))
      .foreach { rec =>
        writingProgress.record(rec)
        out += rec
      }

    val rate = numAlignments.get() / readingProgress.getElapsedSeconds.toDouble
    logger.info(f"Performed ${numAlignments.get()}%,d full alignments in total ($rate%,.2f alignments/second).")
    logger.info(f"Wrote ${readingProgress.getCount}%,d records.")

    in.safelyClose()
    out.close()


    // Write metrics
    // Detailed metrics
    {
      val total   = metricCounter.total.toDouble
      val metrics = metricCounter.map { case (metric, count) =>
        metric.copy(count = count, frac = count / total)
      }.toSeq.sortBy(-_.count)
      Metric.write(PathUtil.pathTo(this.metrics + ".detailed.txt"), metrics)
    }
    // Summary metrics
    Metric.write(PathUtil.pathTo(this.metrics + ".summary.txt"), IdentifyPrimersMetric(metricCounter))
  }

  /** Creates a new [[BatchAligner]]. */
  private def newAligner: BatchAligner[Primer, SamRecordAlignable] = {
    BatchAligner(matchScore, mismatchScore, gapOpen, gapExtend, AlignmentMode.Glocal, this.kswExecutable)
  }

  // NB: batching alignment inputs to the aligner (i.e. ksw) is empirically faster than given them all or just one at a time.
  private def getAlignmentResults(alignmentTasks: Seq[AlignmentTask[Primer, SamRecordAlignable]],
                                  aligner: BatchAligner[Primer, SamRecordAlignable]): Option[PrimerMatch] = {
    case class PrimerAndScore(primer: Primer, score: Int)

    // Get the alignment results
    val alignmentResults: Seq[PrimerAndScore] = alignmentTasks.toIterator.zip(aligner.iterator)
      // Keep results that meet the minimum score and align with a minimum # of query bases
      .filter { case (alignmentInput, alignmentResult) =>
        val minQueryEnd = alignmentInput.queryLength - slop
        val alignmentScoreRate = alignmentResult.score * alignmentInput.query.length.toDouble
        alignmentScoreRate >= minAlignmentScoreRate && alignmentResult.queryEnd >= minQueryEnd
      }
      // now just keep the primer and score
      .map { case (alignmentInput, alignmentResult) => PrimerAndScore(alignmentInput.query, alignmentResult.score) }
      // get the best two alignment results by score
      .maxNBy(n = 2, _.score)

    // Create a primer match if alignments were found (i.e. a Option[PrimerMatch])
    alignmentResults match {
      case Seq()               => None
      case Seq(best)           =>
        val secondBestScore = (minAlignmentScoreRate * best.primer.length).toInt
        Some(FullAlignmentPrimerMatch(primer = best.primer, score = best.score, secondBestScore = secondBestScore))
      case Seq(best, nextBest) => Some(FullAlignmentPrimerMatch(primer = best.primer, score = best.score, secondBestScore = nextBest.score))
      case _                   => unreachable("Should have returned at most two items.")
    }
  }

  /** Processes a single batch of templates. */
  def processBatch(templates: Seq[Template],
                   metricCounter: SimpleCounter[TemplateTypeMetric],
                   progress: ProgressLogger): Seq[Template] = {

    val counter = new SimpleCounter[TemplateTypeMetric]()
    val aligner = newAligner

    val templateMatchOptions = templates.toIterator.map { template =>
      // match up to but not including full alignment
      val r1MatchOption = template.r1.map { r => fwdMatcher.matchBasedOnPositionOrUngappedAlignment(r) }
      val r2MatchOption = template.r2.map { r => revMatcher.matchBasedOnPositionOrUngappedAlignment(r) }

      // add any alignment tasks
      Seq(r1MatchOption, r2MatchOption).flatten.foreach {
        case Right(alignmentTasks) => alignmentTasks.foreach(t => aligner.append(t))
        case Left(_)               => Unit
      }

      (template, r1MatchOption, r2MatchOption)
    }

    // run through the match options, retrieving any alignment tasks that were performed
    templateMatchOptions.foreach { case (template, r1MatchOption, r2MatchOption) =>
      // get the final primer match, if any.  We must retrieve results from the aligner if we sent tasks
      val r1Match = r1MatchOption.flatMap {
        case Left(pm)              => Some(pm)
        case Right(alignmentTasks) => getAlignmentResults(alignmentTasks, aligner)
      }
      val r2Match = r2MatchOption.flatMap {
        case Left(pm)              => Some(pm)
        case Right(alignmentTasks) => getAlignmentResults(alignmentTasks, aligner)
      }

      // add the three prime matching
      val r1ThreePrimeMatch = template.r1.flatMap { r1 => matchThreePrime(r1, r1Match, fwdMatch=true) }
      val r2ThreePrimeMatch = template.r2.flatMap { r2 => matchThreePrime(r2, r2Match, fwdMatch=false) }

      // Get information about the matches
      val templateTypes = (template.r1, template.r2) match {
        case (Some(r1), Some(r2)) =>
          val rType = (r1.mapped, r2.mapped) match {
            case (true, true)   => TemplateType.MappedPair
            case (true, false)  => TemplateType.Unpaired
            case (false, true)  => TemplateType.Unpaired
            case (false, false) => TemplateType.UnmappedPair
          }
          val mType = formatPair(r1, r2, r1Match, r2Match, r1ThreePrimeMatch, r2ThreePrimeMatch)
          TemplateTypeMetric(rType, mType, r1Match, r2Match)
        case (Some(r1), None) =>
          require(!r1.paired, s"Found paired read but missing R2 for ${r1.name}")
          val rType = if (r1.mapped) TemplateType.MappedFragment else TemplateType.UnmappedFragment
          val mType = formatFragment(r1, r1Match, r1ThreePrimeMatch)
          TemplateTypeMetric(rType, mType, r1Match, r2Match)
        case _ =>
          throw new IllegalStateException(s"Template did not have an R1: ${template.name}")
      }

      counter.count(templateTypes)
    }

    require(aligner.numAdded == aligner.numRetrieved, s"added: ${aligner.numAdded} alignments: ${aligner.numRetrieved}")
    require(aligner.numAvailable == 0, s"Found alignments available: ${aligner.numAvailable}")

    aligner.close()

    numAlignments.addAndGet(aligner.numRetrieved)
    metricCounter.synchronized {
      metricCounter += counter
      templates.flatMap(_.allReads).foreach { rec =>
        if (progress.record(rec)) {
          val rate = numAlignments.get() / progress.getElapsedSeconds.toDouble
          logger.info(f"Performed ${numAlignments.get()}%,d full alignments so far ($rate%,.2f alignments/second).")
        }
      }
    }

    templates
  }


  private def matchThreePrime(rec: SamRecord, fivePrimeMatch: Option[PrimerMatch], fwdMatch: Boolean): Option[PrimerMatch] = if (!threePrime) None else {
    // FIXME
    throw new NotImplementedError("Three-prime matching currently not supported, but is planned.")
  }

  /** Adds tags to the records based on the primer matching results. */
  private def formatPair(r1: SamRecord,
                         r2: SamRecord,
                         r1FivePrimeMatch: Option[PrimerMatch],
                         r2FivePrimeMatch: Option[PrimerMatch],
                         r1ThreePrimeMatch: Option[PrimerMatch],
                         r2ThreePrimeMatch: Option[PrimerMatch]): PrimerPairMatchType = {
    import PrimerPairMatchType._

    // Set the primer pair match type
    val matchType: PrimerPairMatchType = (r1FivePrimeMatch, r2FivePrimeMatch) match {
      case (Some(fwd), Some(rev))            => if (fwd.primer.pair_id == rev.primer.pair_id) Canonical else NonCanonical
      case (Some(_), None) | (None, Some(_)) => Single
      case _                                 => NoMatch
    }
    r1(PrimerPairMatchTypeTag) = matchType.toString

    // Set the per-primer/per-read match metadata
    val forwardInfo = r1FivePrimeMatch.map(_.info(r1, forward = true)).getOrElse(NoPrimerMatchInfo)
    val reverseInfo = r2FivePrimeMatch.map(_.info(r2, forward = false)).getOrElse(NoPrimerMatchInfo)
    Seq(r1, r2).foreach { rec =>
      rec(PrimerInfoForwardTag) = forwardInfo
      rec(PrimerInfoReverseTag) = reverseInfo
    }

    // TODO: three prime

    matchType
  }

  /** Adds tags to the record based on the primer matching results. */
  private def formatFragment(frag: SamRecord, fragFivePrimeMatch: Option[PrimerMatch], fragThreePrimeMatch: Option[PrimerMatch]): PrimerPairMatchType = {
    import PrimerPairMatchType._
    val forwardInfo = fragFivePrimeMatch.map(_.info(frag, forward = true)).getOrElse(NoPrimerMatchInfo)

    val matchType: PrimerPairMatchType = fragFivePrimeMatch match {
      case Some(pm) => Single
      case None     => NoMatch
    }

    frag(PrimerPairMatchTypeTag) = matchType.toString
    frag(PrimerInfoForwardTag)   = forwardInfo
    frag(PrimerInfoReverseTag)   = NoPrimerMatchInfo

    // TODO: three prime

    matchType
  }
}



object IdentifyPrimers {
  /** An implicit class that adds support for getting the maximum two values, if they exist. */
  implicit class MaxTwoBy[A](values: Iterator[A]) {
    def maxTwoBy[B](f: A => B)(implicit cmp: Ordering[B]): (Option[A], Option[A]) = {
      var best: Option[A]          = None
      var bestValue: Option[B]     = None
      var nextBest: Option[A]      = None
      var nextBestValue: Option[B] = None

      values.foreach { cur =>
        val curValue = f(cur)

        if (bestValue.forall ( v => cmp.lt(v, curValue))) {
          best = Some(cur)
          bestValue = Some(curValue)
        }
        else if (nextBestValue.forall ( v => cmp.lt(v, curValue))) {
          nextBest = Some(cur)
          nextBestValue = Some(curValue)
        }
      }

      (best, nextBest)

      // NB: this is slightly slower than the implementation above.
      /*
      values.foldLeft((Option.empty[A], Option.empty[A])) { case ((maybeBest, maybeNextBest), value) =>
        (maybeBest, maybeNextBest) match {
          case (None, _)                    => (Some(value), None)
          case (Some(best), None)           => if (cmp.lt(f(best), f(value))) (maybeBest, None) else (maybeBest, None)
          case (Some(best), Some(nextBest)) =>
            if (cmp.lt(f(best), f(value))) (Some(value), maybeBest)
            else if (cmp.lt(f(nextBest), f(value))) (maybeBest, Some(value))
            else (maybeBest, maybeNextBest)
        }
      }
      */
    }
  }



  object IdentifyPrimersMetric {

    def apply(templateTypesCounter: SimpleCounter[TemplateTypeMetric]): IdentifyPrimersMetric = {
      import PrimerPairMatchType._
      import TemplateType._

      val readTypeCounter    = new SimpleCounter[TemplateType]()
      val matchTypeCounter   = new SimpleCounter[PrimerPairMatchType]()
      val primerMatchCounter = new SimpleCounter[String]()

      templateTypesCounter.foreach { case (templateTypes, count) =>
        readTypeCounter.count(templateTypes.template_type, count)
        matchTypeCounter.count(templateTypes.primer_pair_match_type, count)

        val primer_match_types = Seq(templateTypes.r1_primer_match_type, templateTypes.r2_primer_match_type)
        primer_match_types.foreach { primerMatchType =>
          primerMatchCounter.count(primerMatchType, count)
        }
      }

      val mapped_pairs       = readTypeCounter.countOf(MappedPair)
      val unpaired           = readTypeCounter.countOf(Unpaired)
      val unmapped_pairs     = readTypeCounter.countOf(UnmappedPair)
      val mapped_fragments   = readTypeCounter.countOf(MappedFragment)
      val unmapped_fragments = readTypeCounter.countOf(UnmappedFragment)


      new IdentifyPrimersMetric(
        templates                 = readTypeCounter.total,
        pairs                     = mapped_pairs + unpaired + unmapped_pairs,
        fragments                 = mapped_fragments + unmapped_fragments,
        mapped_pairs              = mapped_pairs,
        unpaired                  = unpaired,
        unmapped_pairs            = unmapped_pairs,
        mapped_fragments          = mapped_fragments,
        unmapped_fragments        = unmapped_fragments,
        canonical_primer_pair     = matchTypeCounter.countOf(Canonical),
        non_canonical_primer_pair = matchTypeCounter.countOf(NonCanonical),
        single_primer_pair        = matchTypeCounter.countOf(Single),
        no_primer_pair            = matchTypeCounter.countOf(NoMatch),
        match_attempts            = primerMatchCounter.total,
        location                  = primerMatchCounter.countOf(PrimerMatch.toName[LocationBasedPrimerMatch]),
        mismatch                  = primerMatchCounter.countOf(PrimerMatch.toName[MismatchAlignmentPrimerMatch]),
        full_alignment            = primerMatchCounter.countOf(PrimerMatch.toName[FullAlignmentPrimerMatch]),
        no_match                  = primerMatchCounter.countOf(PrimerMatch.NoPrimerMatchName)
      )
    }
  }

  // TODO: document
  /**
    *
    * @param templates
    * @param pairs
    * @param fragments
    * @param mapped_pairs
    * @param unpaired
    * @param unmapped_pairs
    * @param mapped_fragments
    * @param unmapped_fragments
    * @param canonical_primer_pair
    * @param non_canonical_primer_pair
    * @param single_primer_pair
    * @param no_match
    * @param match_attempts
    * @param location
    * @param mismatch
    * @param full_alignment
    */
  case class IdentifyPrimersMetric
  (templates: Long = 0,
   pairs: Long = 0,
   fragments: Long = 0,
   mapped_pairs: Long = 0,
   unpaired: Long = 0,
   unmapped_pairs: Long = 0,
   mapped_fragments: Long = 0,
   unmapped_fragments: Long = 0,
   canonical_primer_pair: Long = 0,
   non_canonical_primer_pair: Long = 0,
   single_primer_pair: Long = 0,
   no_primer_pair: Long = 0,
   match_attempts: Long = 0,
   location: Long = 0,
   mismatch: Long = 0,
   full_alignment: Long = 0,
   no_match: Long = 0
  ) extends Metric

  object TemplateTypeMetric {

    def apply(readType: TemplateType,
              primerPairMatchType: PrimerPairMatchType,
              r1PrimerMatchType: Option[PrimerMatch],
              r2PrimerMatchType: Option[PrimerMatch]
             ): TemplateTypeMetric = {
      TemplateTypeMetric(
        template_type          = readType,
        primer_pair_match_type = primerPairMatchType,
        r1_primer_match_type   = toName(r1PrimerMatchType),
        r2_primer_match_type   = toName(r2PrimerMatchType)
      )
    }

    private def toName[T <: PrimerMatch](primerMatch: Option[T]): String = primerMatch.map(_.toName).getOrElse(PrimerMatch.NoPrimerMatchName)
  }


  // TODO: document
  /**
    *
    * @param template_type
    * @param primer_pair_match_type
    * @param r1_primer_match_type
    * @param r2_primer_match_type
    * @param count
    * @param frac
    */
  case class TemplateTypeMetric
  (template_type: TemplateType,
   primer_pair_match_type: PrimerPairMatchType,
   r1_primer_match_type: String,
   r2_primer_match_type: String,
   count: Long = 0,
   frac: Double = 0d
  ) extends Metric

  sealed trait TemplateType extends EnumEntry

  // TODO: document
  object TemplateType extends FgBioEnum[TemplateType] {
    case object MappedPair extends TemplateType
    case object Unpaired extends TemplateType
    case object UnmappedPair extends TemplateType
    case object MappedFragment extends TemplateType
    case object UnmappedFragment extends TemplateType

    override def values: immutable.IndexedSeq[TemplateType] = findValues
  }

  sealed trait PrimerPairMatchType extends EnumEntry

  // TODO: document
  object PrimerPairMatchType extends FgBioEnum[PrimerPairMatchType] {
    case object Canonical extends PrimerPairMatchType
    case object NonCanonical extends PrimerPairMatchType
    case object Single extends PrimerPairMatchType
    case object NoMatch extends PrimerPairMatchType

    override def values: immutable.IndexedSeq[PrimerPairMatchType] = findValues
  }

  object PrimerMatch {
    val InfoDelimiter: String     = ","
    val NoPrimerMatchName: String = "NoPrimerMatch"

    def toName[T <: PrimerMatch : TypeTag]: String =  typeOf[T] match {
      case t if t =:= typeOf[LocationBasedPrimerMatch]     => "Location"
      case t if t =:= typeOf[MismatchAlignmentPrimerMatch] => "Mismatch"
      case t if t =:= typeOf[FullAlignmentPrimerMatch]     => "Alignment"
      case _ => unreachable(s"Unknown primer match type: ${this.getClass.getSimpleName}.")
    }
  }

  // TODO: document
  sealed trait PrimerMatch {
    def primer: Primer

    final def info(rec: SamRecord, forward: Boolean): String = {
      val baseInfo = Seq(
        primer.pair_id,
        primer.primer_id,
        primer.ref_name + ":" + primer.start + "-" + primer.end,
        if (forward) "+" else "-",
        0, // TODO: offset from the 5' end,
        this.toName,
      ).map(_.toString)
      (baseInfo ++ this._info(rec, forward)).mkString(PrimerMatch.InfoDelimiter)
    }

    protected def _info(rec: SamRecord, forward: Boolean): Seq[Any]

    def toName: String
  }
  // TODO: document
  case class LocationBasedPrimerMatch(primer: Primer, numMismatches: Int) extends PrimerMatch {
    protected def _info(rec: SamRecord, forward: Boolean): Seq[Any] = Seq(numMismatches)
    def toName: String = PrimerMatch.toName[LocationBasedPrimerMatch]
  }

  // TODO: document
  case class MismatchAlignmentPrimerMatch(primer: Primer, numMismatches: Int, nextNumMismatches: Int) extends PrimerMatch {
    protected def _info(rec: SamRecord, forward: Boolean): Seq[Any] = {
      val nextOrNa = if (nextNumMismatches == Int.MaxValue) "na" else nextNumMismatches
      Seq(numMismatches, nextOrNa)
    }
    def toName: String = PrimerMatch.toName[MismatchAlignmentPrimerMatch]
  }

  // TODO: document
  case class FullAlignmentPrimerMatch(primer: Primer, score: Int, secondBestScore: Int) extends PrimerMatch {
    protected def _info(rec: SamRecord, forward: Boolean): Seq[Any] = Seq(score, secondBestScore)
    def toName: String = PrimerMatch.toName[FullAlignmentPrimerMatch]

  }

  object Primer {
    /** Writes the given primers to file.  Reverse strand primers are written with their sequence reverse complemented. */
    def write(path: FilePath, primers: TraversableOnce[Primer]): Unit = {
      val newPrimers = primers.map { primer =>
        if (primer.forward) primer
        else primer.copy(sequence = SequenceUtil.reverseComplement(primer.sequence))
      }
      Metric.write(path, newPrimers)
    }
  }

  /** A locatable class for a single primer of a primer pair.
    *
    * The bases should be 5'->3' on the genomic forward strand, which facilitates matching against [[SamRecord]]s.
    *
    * @param pair_id the canonical primer pair identifier, unique across all primer pairs.
    * @param primer_id the canonical primer identifier, unique across all primers.
    * @param sequence the primer sequence, in 5'->3' on the genomic forward strand.
    * @param ref_name the reference name to which this primer targets.
    * @param start the reference start position at which this primer starts.
    * @param end the reference end position at which this primer starts.
    * @param forward true if the primer maps to the forward genomic strand, false otherwise.
    */
  case class Primer(pair_id: String,
                    primer_id: String,
                    sequence: String,
                    ref_name: String,
                    start: Int,
                    end: Int,
                    forward: Boolean) extends Locatable with Alignable with Metric {
    override def getContig: String = ref_name
    override def getStart: Int = start
    override def getEnd: Int = end
    override def length: Int = end - start + 1
    def reverse: Boolean = !this.forward

    val bases: Array[Byte] = sequence.getBytes

    this.sequence.zipWithIndex.foreach { case (base, index) =>
      if (!SequenceUtil.isValidBase(base.toByte) && !SequenceUtil.isIUPAC(base.toByte)) {
        val prefix = sequence.substring(0, index)
        val base   = sequence.charAt(index)
        val suffix = sequence.substring(index+1)
        throw new IllegalArgumentException(s"Found an invalid base for primer $pair_id/$primer_id: $prefix[$base]$suffix")
      }
    }
  }

  /** Companion class to [[PrimerMatcher]] class that provides factory methods. */
  object PrimerMatcher {

    /** Converts strand to a True if forward, false if reverse. */
    private def strandToForward(strand: String): Boolean = strand.toLowerCase match {
      case "+" | "f" | "fwd" | "for" | "forward" | "positive" | "true" => true
      case "-" | "r" | "rev" | "reverse" | "negative" | "false"        => false
      case _ => throw new IllegalArgumentException(s"Could not parse strand: $strand")
    }

    /** Builds a forward and reverse matcher from the primers at the given path. */
    def build(path: FilePath,
              aligner: Aligner,
              slop: Int,
              maxMismatchRate: Double,
              minAlignmentScoreRate: Double,
              withFullAlignment: Boolean,
              revComp: Boolean = true): (PrimerMatcher, PrimerMatcher) = {
      val parser  = DelimitedDataParser(path, '\t')
      val primers = parser.map { row =>
        val forward  = strandToForward(row.apply[String]("strand"))
        val sequence = row.apply[String]("sequence")
        Primer(
          pair_id   = row.apply[String]("pair_id"),
          primer_id = row.apply[String]("primer_id"),
          sequence  = if (forward) sequence else SequenceUtil.reverseComplement(sequence),
          ref_name  = row.apply[String]("ref_name"),
          start     = row.apply[Int]("start"),
          end       = row.apply[Int]("end"),
          forward   = forward
        )
      }.toSeq
      build(primers, aligner, slop, maxMismatchRate, minAlignmentScoreRate, withFullAlignment)
    }

    /** Builds a forward and reverse matcher from the given primers. */
    def build(primers: Seq[Primer],
              aligner: Aligner,
              slop: Int,
              maxMismatchRate: Double,
              minAlignmentScoreRate: Double,
              withFullAlignment: Boolean): (PrimerMatcher, PrimerMatcher) = {
      val (fwdPrimers: Seq[Primer], revPrimers: Seq[Primer]) = primers.partition(_.forward)
      val fwdMatcher = new PrimerMatcher(fwdPrimers, aligner, slop, maxMismatchRate, minAlignmentScoreRate, isForward=true, withFullAlignment=withFullAlignment)
      val revMatcher = new PrimerMatcher(revPrimers, aligner, slop, maxMismatchRate, minAlignmentScoreRate, isForward=false, withFullAlignment=withFullAlignment)

      // Validate a bunch of things
      validate(primers, fwdMatcher, revMatcher)

      (fwdMatcher, revMatcher)
    }

    /** Validates a forward and reverse matcher given a set of primers. */
    private def validate(primers: Seq[Primer], fowdMatcher: PrimerMatcher, revMatcher: PrimerMatcher): Unit = {
      val fwdDetector = fowdMatcher.detector
      val revDetector = revMatcher.detector

      // Validate that two primers exist for each pair, and that one is forward and the other is reverse
      primers.groupBy(_.pair_id).foreach { case (pairId, primersForPair) =>
        primersForPair match {
          case Seq(first, second) =>
            if (first.forward == second.forward) {
              val tpe = if (first.forward) "forward" else "reverse"
              throw new IllegalArgumentException(s"Found two $tpe primers for pair with id '$pairId': " + primersForPair.map(_.primer_id).mkString(", "))
            }
          case _ =>
            throw new IllegalArgumentException(s"Found ${primersForPair.length} primers for pair with id '$pairId': " + primersForPair.map(_.primer_id).mkString(", "))
        }
      }

      // Validate we do not have forward primers that have the same refName/start, or reverse primers with the same refName/end
      primers.foreach { primer =>
        val overlaps = (fowdMatcher.detector.getOverlaps(primer).iterator() ++ revDetector.getOverlaps(primer).iterator())
          .filter { overlap => primer != overlap && overlap.forward == primer.forward && overlap.ref_name == primer.ref_name }
          .filter { overlap => if (primer.forward) overlap.start == primer.start else overlap.end == primer.end }
        if (overlaps.nonEmpty) {
          throw new IllegalArgumentException(s"Found primers had the same location:\n$primer\n" + overlaps.map(_.toString).mkString("\n"))
        }
      }

      // Validate we do not have forward primers that have the same refName/start or reverse primers with the same refName/end
      primers.foreach { primer =>
        val overlaps = (fwdDetector.getOverlaps(primer).iterator() ++ revDetector.getOverlaps(primer).iterator())
          .filter { overlap => primer != overlap && overlap.forward == primer.forward && overlap.ref_name == primer.ref_name }
          .filter { overlap => if (primer.forward) overlap.start == primer.start else overlap.end == primer.end }
        if (overlaps.nonEmpty) {
          throw new IllegalArgumentException(s"Found primers had the same location:\n$primer\n" + overlaps.map(_.toString).mkString("\n"))
        }
      }
    }

    /** Counts the # of mismatches, allowing the primer to have IUPAC bases. */
    private[bam] def numMismatches(bases: Array[Byte], primer: Array[Byte]): Int = {
      // NB: the primer may be longer than bases!
      val length = math.min(bases.length, primer.length)
      var count = 0
      forloop(from = 0, until = length) { index =>
        if (!SequenceUtil.readBaseMatchesRefBaseWithAmbiguity(bases(index), primer(index))) count += 1
      }
      count
      //bases.zip(primer).count { case (l, r) => !SequenceUtil.readBaseMatchesRefBaseWithAmbiguity(l.toByte, r.toByte) }
    }
  }

  /** A little class that wraps a [[SamRecord]] to make it [[Alignable]] and also to defer extracting the bases to align.
    * NB: end is exclusive, and start and end are zero-based. */
  private[bam] case class SamRecordAlignable(rec: SamRecord, offset: Int, override val length: Int) extends Alignable {
    def bases: Array[Byte] = rec.bases.slice(offset, offset + length)
  }

  /** A primer matcher.  Attempts to match based on location, then based on a mismatch-only alignment, then based on a full-alignment.
    *
    * @param primers the primers against which this matcher matches.
    * @param aligner the aligner for full-alignment-based matching.
    * @param slop the slop allowed by this matcher when matching based on location.
    * @param maxMismatchRate the maximum per-base mismatch rate allowed for a location or mismatch-alignment based match.
    * @param minAlignmentScoreRate the minimum per-base alignment score rate for a gapped alignment based match.  The
    *                              rate for alignment is the score divided by the primer length.
    * @param isForward true if we are to align the left side of the read, otherwise the right side of the read
    * @param withFullAlignment true to perform full alignment, otherwise skip full alignment.
    */
  class PrimerMatcher(val primers: Seq[Primer],
                      val aligner: Aligner,
                      val slop: Int,
                      val maxMismatchRate: Double,
                      val minAlignmentScoreRate: Double,
                      val isForward: Boolean,
                      val withFullAlignment: Boolean) {
    import PrimerMatcher._

    /** The number of primers. */
    def length: Int = primers.length

    /** Attempts to match the 5' end of the read with the given set of primers. This stops short of performing a full
      * alignment, and instead, produces an alignment task that can be performed by the caller.  This may be useful if
      * alignment is expensive or is required many times. */
    def matchBasedOnPositionOrUngappedAlignment(rec: SamRecord): Either[PrimerMatch, Seq[AlignmentTask[Primer, SamRecordAlignable]]] = {
      // A cache of [[SamRecordAlignable]] that we have already created, to reduce memory consumption creating many [[SamRecordAlignable]]s
      val recordCache = scala.collection.mutable.HashMap[(Int,Int), SamRecordAlignable]()

      matchOnLocation(rec).orElse { matchWithMismatchAlignment(rec) } match {
        case Some(primerMatch) => Left(primerMatch)
        case None              =>
          val inputs = if (isForward) {
            this.primers.iterator.map { primer =>
              val targetOffset = 0
              val targetLength = math.min(primer.sequence.length + slop, rec.length) - targetOffset
              val target       = recordCache.getOrElseUpdate((targetOffset, targetLength), SamRecordAlignable(rec, targetOffset, targetLength))
              AlignmentTask(query=primer, target=target)
            }
          }
          else {
            this.primers.iterator.map { primer =>
              val targetOffset = math.max(0, rec.length - primer.length - slop)
              val targetLength = rec.length - targetOffset
              val target       = recordCache.getOrElseUpdate((targetOffset, targetLength), SamRecordAlignable(rec, targetOffset, targetLength))
              AlignmentTask(query=primer, target=target)
            }
          }
          Right(inputs.toSeq)
      }
    }

    /** Attempts to match the 5' end of the read with the given set of primers. */
    def matchIt(rec: SamRecord): Option[PrimerMatch] = {
      matchOnLocation(rec)
        .orElse { matchWithMismatchAlignment(rec) }
        .orElse { if (withFullAlignment) matchWithFullAlignment(rec) else None }
    }

    /** The [[OverlapDetector]] for the primers. */
    private val detector: OverlapDetector[Primer] = {
      val d = new OverlapDetector[Primer](0, 0)
      this.primers.foreach { primer => d.addLhs(primer, primer) }
      d
    }

    /** Returns a location-based match, otherwise None */
    private[bam] def matchOnLocation(rec: SamRecord): Option[LocationBasedPrimerMatch] = if (rec.unmapped) None else {
      val pos = if (isForward) rec.unclippedStart else rec.unclippedEnd
      matchOnLocation(rec.refName, pos)
        .flatMap { p => toLocationBasedPrimerMatch(mismatchAlign(rec, p)) }
    }

    /** Returns a mismatch-based alignment match, otherwise None */
    private[bam] def mismatchAlign(rec: SamRecord, primer: Primer): Option[MismatchAlignmentPrimerMatch] = {
      val maxMismatches = math.min(rec.length, primer.length) * this.maxMismatchRate
      val mm = {
        if (isForward) numMismatches(rec.bases, primer.bases)
        else numMismatches(rec.bases.drop(math.max(0, rec.length - primer.length)), primer.bases)
      }
      if (mm <= maxMismatches) Some(MismatchAlignmentPrimerMatch(primer, mm, Int.MaxValue)) else None
    }

    /** Converts a [[MismatchAlignmentPrimerMatch]] to a [[LocationBasedPrimerMatch]]. */
    private def toLocationBasedPrimerMatch(primerMatch: Option[MismatchAlignmentPrimerMatch]): Option[LocationBasedPrimerMatch] = {
      primerMatch.map { m => LocationBasedPrimerMatch(primer = m.primer, numMismatches = m.numMismatches) }
    }

    /** Determines if the primer is close enoguh to the given read defined by start/end. */
    private[bam] def locationCloseEnough(primer: Primer, pos: Int): Boolean = {
      if (isForward) {
        math.abs(primer.start - pos) <= slop
      }
      else {
        math.abs(primer.end - pos) <= slop
      }
    }

    /** Matches the read defined by refName/start/end based on location. */
    private[bam] def matchOnLocation(refName: String, pos: Int): Option[Primer] = {
      val interval = new Interval(refName, math.max(1, pos-slop), pos+slop) // TODO: off the end of the refNameosome?
      detector.getOverlaps(interval)
        .iterator()
        .filter { primer => locationCloseEnough(primer, pos)}
        .toSeq match {
        case Seq()       => None
        case Seq(primer) => Some(primer)
        case _primers    => unreachable(s"Found multiple primers for $refName:$pos\n${_primers.mkString("\n")}")
      }
    }

    /** Examines all primers to find the best mismatch-based alignment match. */
    private[bam] def matchWithMismatchAlignment(rec: SamRecord): Option[MismatchAlignmentPrimerMatch] = {
      val alignments = primers.flatMap { primer: Primer => mismatchAlign(rec, primer) }
      getBestMismatchAlignment(alignments)
    }

    /** Examines all primers to find the best full-alignment-based match. */
    private[bam] def getBestMismatchAlignment(alignments: Seq[MismatchAlignmentPrimerMatch]): Option[MismatchAlignmentPrimerMatch] = {
      if (alignments.isEmpty) None
      else {
        val best: MismatchAlignmentPrimerMatch = alignments.minBy(_.numMismatches)
        alignments.filter(_.numMismatches != best.numMismatches) match {
          case Seq() => Some(best.copy(nextNumMismatches = Int.MaxValue))
          case alns  => Some(best.copy(nextNumMismatches =  alns.minBy(_.numMismatches).numMismatches))
        }
      }
    }

    // A little clss to store an alignment to a given primer
    private case class AlignmentAndPrimer(alignment: Alignment, primer: Primer)

    /** A little helper method for matchWithFullAlignment to create a [[FullAlignmentPrimerMatch]]. */
    private def toFullAlignmentPrimerMatch(best: AlignmentAndPrimer, nextBestScore: Option[Int]): Option[FullAlignmentPrimerMatch] = {
      val primerMatch = FullAlignmentPrimerMatch(
        primer          = best.primer,
        score           = best.alignment.score,
        secondBestScore = nextBestScore.getOrElse((minAlignmentScoreRate * best.primer.length).toInt)
      )
      Some(primerMatch)
    }

    /** Returns a full-alignment-based match, otherwise None */
    private[bam] def matchWithFullAlignment(rec: SamRecord): Option[FullAlignmentPrimerMatch] = {
      // TODO: cache alignments?
      val alignments: IndexedSeq[AlignmentAndPrimer] = if (isForward) {
        this.primers.iterator.flatMap { primer =>
          val target    = rec.bases.slice(0, math.min(primer.sequence.length + slop, rec.length))
          val alignment = this.aligner.align(query = primer.bases, target = target)
          if (alignment.score / primer.bases.length.toDouble >= this.minAlignmentScoreRate) {
            Some(AlignmentAndPrimer(alignment, primer))
          }
          else {
            None
          }
        }.toIndexedSeq
      }
      else {
        this.primers.iterator.flatMap { primer =>
          val startIndex = math.max(0, rec.length - primer.bases.length - slop)
          val target     = rec.bases.drop(startIndex)
          val alignment  = this.aligner.align(query = primer.bases, target = target)
          if (alignment.score / primer.bases.length.toDouble >= this.minAlignmentScoreRate) {
            Some(AlignmentAndPrimer(alignment, primer))
          }
          else {
            None
          }
        }.toIndexedSeq
      }

      if (alignments.isEmpty) None else {
        val best: AlignmentAndPrimer = alignments.maxBy(_.alignment.score)
        alignments.filter(_.alignment.score != best.alignment.score) match {
          case Seq() => toFullAlignmentPrimerMatch(best, None)
          case alns  => toFullAlignmentPrimerMatch(best, Some(alns.maxBy(_.alignment.score).alignment.score))
        }
      }
    }
  }
}